---
layout: post
title: CVE-2022-22265 Samsung npu driver
date: 2024-08-12
categories: ["CVE", "Exploit", "Linux", "Kernel", "Android"]
thumbnail: "assets/images/thumb_4.png"
---

## Introduction

I wanted to do a bug from Samsung and I chose this [https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-22265.html](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-22265.html). It is well explained, when you read it, you'll know wich involves a double free. Finally I chose another more generic strategy that I am going to explain next. Linux kernel 5.10.177.

## Warning

Getting context from npu driver..

![policy_npu](/assets/images/policy_npu.png)

The NPU driver in this version is restricted from shell. If you want to use this exploit, you'll need to adapt it to an unstrusted app. 

![policy_shell](/assets/images/policy_shell.png)
![policy_unstrusted_app](/assets/images/policy_untrusted_app.png)

Also, this NPU driver version had the bug patched, so I modified the communication with the firmware in **npu-interface.c** (because the whole analysis it was unnecessary, I did just enough to avoid crashing, each firmware includes its own extra check code, I don't want to do hard work for nothing, thanks). If you want help with reversing the firmware you could look at [this](https://blog.impalabs.com/2103_reversing-samsung-npu.html) and [this](https://blog.impalabs.com/2110_exploiting-samsung-npu.html). You'll need to adapt it as well.

![npu_patched](/assets/images/npu_patched.png)

## The bug

## Strategy

The signalfd object will occupy the kernel's freed object (size 128). Next, the exploit frees the object again using the ioctl command VS4L_VERTEXIOC_STREAM_OFF and reuses the freed kernel object with a set of pipe_buffer structures using fcntl(fd, F_SETPIPE_SZ, size), similar to the first strategy. This is done to locate the signalfd object and perform cross-cache operations later, by closing the pipe_buffer object (located as well) and emptying the page of the signalfd object. After this, I perform a PTE spray to match the signalfd UAF and manage the page. Once this is done, signalfd has limitations (I'll explain later), so I migrate to a virtual memory area to manage the page (full phys r/w). Next, I locate the kernel base to disable SELinux and access init_task, finding current->mm->pgd to perform an MMU walk, and set the libbase.so page with permissions to inject shellcode over LogLine method (within the LogMessage object), wich will be executed by the init process.

## signalfd as a UAF object

## spray pipe_buffer to locate signalfd

## cross cache

## spray pte

## migrate to a vma

## locate kernel

## disable selinux

## inject code into libbase.so

## trigger and getting reverse root shell

##### Demo

![thumb](/assets/images/thumb_4.png)
![reverse shell](/assets/images/reverse_shell.png)

##### Full exploit

[https://gist.github.com/soez/66eabe37a8dec0937cba8e0cb1ab7ebb](https://gist.github.com/soez/66eabe37a8dec0937cba8e0cb1ab7ebb)

## Improvements

## References

[https://blog.impalabs.com/2103_reversing-samsung-npu.html](https://blog.impalabs.com/2103_reversing-samsung-npu.html)
[https://blog.impalabs.com/2110_exploiting-samsung-npu.html](https://blog.impalabs.com/2110_exploiting-samsung-npu.html)
